# Stufio Framework - GitHub Copilot Instructions

## Framework Overview

The Stufio Framework is a modular FastAPI-based backend framework designed for scalable modern web applications. It provides integrated database support for MongoDB, ClickHouse, and Redis with a focus on performance, modularity, and maintainability.

## Core Architecture Principles

### 1. Database Usage Patterns

#### MongoDB (Primary Database)
- **Purpose**: Primary transactional database for application data
- **Usage**: User accounts, settings, configurations, real-time session data
- **Base Model**: `MongoBase` (extends ODMantic Model)
- **CRUD Pattern**: `CRUDMongo[ModelType, CreateSchemaType, UpdateSchemaType]`
- **Connection**: Singleton pattern with automatic connection pooling
- **Features**: 
  - Automatic ObjectId serialization
  - Region-aware replica set optimization
  - Metrics tracking for performance monitoring

**Example MongoDB Model:**
```python
from stufio.db.mongo_base import MongoBase, datetime_now_sec
from odmantic import Field

class User(MongoBase):
    email: str = Field(unique=True, index=True)
    name: str
    created_at: datetime = Field(default_factory=datetime_now_sec)
    is_active: bool = True
```

**Example MongoDB CRUD:**
```python
from stufio.crud.mongo_base import CRUDMongo
from .models import User
from .schemas import UserCreate, UserUpdate

class CRUDUser(CRUDMongo[User, UserCreate, UserUpdate]):
    async def get_by_email(self, email: str) -> Optional[User]:
        return await self.get_by_field("email", email)

user_crud = CRUDUser(User)
```

#### ClickHouse (Analytics Database)
- **Purpose**: Time-series data, analytics, metrics, and event tracking
- **Usage**: User activity logs, performance metrics, business intelligence data
- **Base Model**: `ClickhouseBase` (extends Pydantic BaseModel)
- **CRUD Pattern**: `CRUDClickhouse[ModelType, CreateSchemaType, UpdateSchemaType]`
- **Connection**: Cluster-aware with automatic failover and optimization
- **Features**:
  - Connection locality optimization (prefers local nodes)
  - Automatic cluster health monitoring
  - Connection pool management with custom pool sizing

**Example ClickHouse Model:**
```python
from stufio.db.clickhouse_base import ClickhouseBase, datetime_now_sec
from datetime import datetime
from pydantic import Field

class UserActivity(ClickhouseBase):
    id: str = Field(json_schema_extra={"primary_field": True})
    user_id: str
    action: str
    timestamp: datetime = Field(default_factory=datetime_now_sec)
    metadata: dict = {}
    
    class Config:
        table_name = "user_activity"  # Optional: override table name
```

**Example ClickHouse CRUD:**
```python
from stufio.crud.clickhouse_base import CRUDClickhouse
from .models import UserActivity
from .schemas import UserActivityCreate, UserActivityUpdate

class CRUDUserActivity(CRUDClickhouse[UserActivity, UserActivityCreate, UserActivityUpdate]):
    async def get_user_activity_by_date_range(
        self, 
        user_id: str, 
        start_date: datetime, 
        end_date: datetime
    ) -> List[UserActivity]:
        query = """
        SELECT * FROM {table}
        WHERE user_id = {user_id:String}
        AND timestamp BETWEEN {start:DateTime} AND {end:DateTime}
        ORDER BY timestamp DESC
        """
        result = await self.execute_query(
            query.format(table=self.get_table_name()),
            parameters={
                "user_id": user_id,
                "start": start_date,
                "end": end_date
            }
        )
        return [UserActivity(**row) for row in result.named_results()]

activity_crud = CRUDUserActivity(UserActivity)
```

#### Redis (Caching & Session Storage)
- **Purpose**: Caching, session storage, rate limiting, real-time data
- **Usage**: User sessions, temporary data, rate limiting counters, pub/sub messaging
- **Connection**: Cluster-aware with automatic key prefixing
- **Features**:
  - Automatic key prefixing with `REDIS_PREFIX`
  - Cluster support with fallback to single-node
  - Metrics tracking for cache hit/miss rates

**Example Redis Usage:**
```python
from stufio.db.redis import RedisClient

async def cache_user_data(user_id: str, data: dict, ttl: int = 3600):
    client = await RedisClient()
    # Keys are automatically prefixed with settings.REDIS_PREFIX
    await client.setex(f"user:{user_id}", ttl, json.dumps(data))

async def get_cached_user_data(user_id: str) -> Optional[dict]:
    client = await RedisClient()
    cached = await client.get(f"user:{user_id}")
    return json.loads(cached) if cached else None

async def increment_rate_limit(user_id: str, window: int = 60) -> int:
    client = await RedisClient()
    key = f"rate_limit:{user_id}:{int(time.time() // window)}"
    count = await client.incr(key)
    await client.expire(key, window)
    return count
```

### 2. Database Connection Management

#### Dependency Injection Pattern
```python
from stufio.api.deps import get_db, get_clickhouse
from stufio.db.redis import RedisClient

@app.get("/api/user/{user_id}/activity")
async def get_user_activity(
    user_id: str,
    db: AgnosticDatabase = Depends(get_db),
    clickhouse: AsyncClient = Depends(get_clickhouse)
):
    # MongoDB for user data
    user = await user_crud.get(user_id)
    
    # ClickHouse for activity data
    activities = await activity_crud.get_user_activity_by_date_range(
        user_id, start_date, end_date
    )
    
    # Redis for caching
    redis = await RedisClient()
    await redis.setex(f"user_activity:{user_id}", 300, json.dumps(activities))
    
    return {"user": user, "activities": activities}
```

### 3. Error Handling & Performance

#### Database Connection Errors
- Always handle `ClickhouseConnectionError` for ClickHouse operations
- Use `RedisConnectionError` for Redis connection issues
- MongoDB errors are handled by ODMantic/Motor

#### Performance Patterns
- Use connection pooling (configured via settings)
- Enable metrics tracking with `DB_METRICS_ENABLE=True`
- Implement query timeout handling
- Use batch operations for bulk inserts

#### Example Error Handling:
```python
from stufio.db.clickhouse import ClickhouseConnectionError
from stufio.db.redis import RedisConnectionError

async def robust_data_operation(user_id: str):
    try:
        # Primary operation in MongoDB
        user = await user_crud.get(user_id)
        
        # Analytics in ClickHouse (non-critical)
        try:
            await activity_crud.create(UserActivityCreate(
                user_id=user_id,
                action="data_access",
                timestamp=datetime.now(timezone.utc)
            ))
        except ClickhouseConnectionError as e:
            logger.warning(f"ClickHouse logging failed: {e}")
            # Continue without analytics
        
        # Cache result in Redis (non-critical)
        try:
            redis = await RedisClient()
            await redis.setex(f"user:{user_id}", 300, user.model_dump_json())
        except RedisConnectionError as e:
            logger.warning(f"Redis caching failed: {e}")
            # Continue without caching
            
        return user
        
    except Exception as e:
        logger.error(f"Critical database operation failed: {e}")
        raise
```

### 4. Configuration Patterns

#### Database Settings
- `MONGO_DATABASE_URI`: MongoDB connection string with replica set support
- `CLICKHOUSE_DSN`: Primary ClickHouse connection
- `CLICKHOUSE_CLUSTER_DSN_LIST`: List of ClickHouse cluster nodes
- `CLICKHOUSE_CLUSTER_NAME`: Cluster name for health checking
- `REDIS_URL`: Redis connection string
- `REDIS_CLUSTER_NODES`: Comma-separated Redis cluster nodes
- `REDIS_PREFIX`: Automatic key prefixing (default: "stufio:")

#### Performance Tuning
- `CLICKHOUSE_POOL_SIZE`: Connection pool size (default: 20)
- `CLICKHOUSE_MAX_THREADS`: Query execution threads (1-8)
- `DB_METRICS_ENABLE`: Enable performance monitoring
- `APP_REGION`: Region-aware connection optimization

### 5. Module Development Patterns

#### Creating a New Module
```python
# Module structure
my_module/
├── __init__.py
├── api/
│   └── endpoints/
├── crud/
├── models/
├── schemas/
└── migrations/

# Module registration
from stufio.core.module_registry import registry

class MyModule:
    def initialize(self, app):
        # Register API routes
        # Initialize database connections
        # Set up background tasks
        pass

registry.register("my_module", MyModule())
```

### 6. Testing Patterns

#### Database Testing
- Use separate test databases
- Clean up test data between tests
- Mock database connections for unit tests
- Use real databases for integration tests

```python
@pytest.fixture
async def test_db():
    # Setup test database
    yield db
    # Cleanup

async def test_user_creation(test_db):
    user_data = UserCreate(email="test@example.com", name="Test User")
    user = await user_crud.create(user_data)
    assert user.email == "test@example.com"
```

## Best Practices Summary

1. **MongoDB**: Use for primary application data, user accounts, configurations
2. **ClickHouse**: Use for analytics, time-series data, metrics, and event tracking
3. **Redis**: Use for caching, sessions, rate limiting, and temporary data
4. **Always** handle database connection errors gracefully
5. **Enable** metrics tracking for performance monitoring
6. **Use** region-aware configuration for optimal performance
7. **Implement** proper error handling with fallback strategies
8. **Follow** the established CRUD patterns for consistency
9. **Test** database operations with appropriate fixtures
10. **Monitor** connection health and performance metrics

## Database Migration System

The Stufio framework includes a sophisticated migration system that supports both MongoDB and ClickHouse databases with automatic cluster support.

### Migration Structure

Migrations are organized in date-based version folders:
```
module_name/
├── migrations/
│   ├── __init__.py
│   ├── v20250501/          # Version folder (YYYYMMDD format)
│   │   ├── 01_init_collections.py
│   │   ├── 02_create_indexes.py
│   │   └── 03_seed_data.py
│   └── v20250502/
│       └── 01_alter_schema.py
```

### Migration Types

#### MongoDB Migrations
```python
from motor.core import AgnosticDatabase
from stufio.core.migrations.base import MongoMigrationScript

class CreateIndexes(MongoMigrationScript):
    name = "create_indexes"
    description = "Create indexes for performance optimization"
    migration_type = "schema"  # "init", "schema", "data"
    order = 20  # Execution order within version

    async def run(self, db: AgnosticDatabase) -> None:
        # Create unique index
        await db.command({
            "createIndexes": "users",
            "indexes": [
                {
                    "key": {"email": 1},
                    "name": "email_unique",
                    "unique": True
                }
            ]
        })
        
        # Create compound index
        await db.command({
            "createIndexes": "user_activity",
            "indexes": [
                {
                    "key": {"user_id": 1, "timestamp": -1},
                    "name": "user_activity_lookup"
                }
            ]
        })
```

#### ClickHouse Migrations
```python
from clickhouse_connect.driver.asyncclient import AsyncClient
from stufio.core.migrations.base import ClickhouseMigrationScript

class CreateUserActivityTable(ClickhouseMigrationScript):
    name = "create_user_activity_table"
    description = "Create table for user activity tracking"
    migration_type = "schema"
    order = 10

    async def run(self, db: AsyncClient) -> None:
        # Framework automatically handles cluster transformations
        await db.command("""
        CREATE TABLE IF NOT EXISTS user_activity
        (
            id String,
            user_id String,
            action String,
            timestamp DateTime,
            metadata Map(String, String),
            INDEX idx_user_id user_id TYPE bloom_filter GRANULARITY 1,
            INDEX idx_timestamp timestamp TYPE minmax GRANULARITY 3
        )
        ENGINE = MergeTree()
        PARTITION BY toYYYYMM(timestamp)
        ORDER BY (user_id, timestamp)
        TTL timestamp + INTERVAL 1 YEAR
        """)

        # Create materialized view for aggregations
        await db.command("""
        CREATE MATERIALIZED VIEW IF NOT EXISTS user_activity_daily
        ENGINE = AggregatingMergeTree()
        PARTITION BY toYYYYMM(date)
        ORDER BY (user_id, date)
        AS
        SELECT 
            user_id,
            toDate(timestamp) as date,
            countState() as activity_count,
            uniqState(action) as unique_actions
        FROM user_activity
        GROUP BY user_id, date
        """)
```

### Cluster-Aware ClickHouse Migrations

The framework **automatically** transforms ClickHouse migrations for cluster deployments:

1. **Engine Transformation**: `MergeTree` → `ReplicatedMergeTree` with proper ZooKeeper paths
2. **DDL Distribution**: Adds `ON CLUSTER 'cluster_name'` to CREATE/DROP/ALTER statements
3. **Automatic Failover**: Retry logic with connection recovery
4. **Single-Node Compatibility**: Works seamlessly in both single-node and cluster modes

**Configuration Required for Cluster Mode:**
- `CLICKHOUSE_CLUSTER_DSN_LIST`: List of cluster node DSNs
- `CLICKHOUSE_CLUSTER_NAME`: Name of the ClickHouse cluster

### Migration Best Practices

1. **Use Descriptive Names**: `01_create_user_table.py`, `02_add_email_index.py`
2. **Order Matters**: Use numeric prefixes (01, 02, 03) for execution order
3. **Version Folders**: Use `vYYYYMMDD` format for version folders
4. **Idempotent Operations**: Always use `IF NOT EXISTS` and `IF EXISTS`
5. **Error Handling**: Include try-catch blocks for complex operations
6. **TTL Indexes**: Use TTL for automatic data cleanup in both databases

### Migration Execution

Migrations are automatically discovered and executed during application startup:
```python
# In main.py or startup script
from stufio.db.init_db import run_migrations

async def startup():
    await run_migrations(mongodb_client, clickhouse_client)
```

## Module Development Guide

Based on analysis of `stufio-modules-activity` and `stufio-modules-locale`, here's how to create new modules:

### Module Structure

```
stufio-modules-[name]/
├── LICENSE.txt
├── README.md
├── pyproject.toml
└── stufio/
    └── modules/
        └── [name]/
            ├── __init__.py           # Module registration
            ├── __version__.py        # Version info
            ├── module.py             # Main module class
            ├── config.py             # Settings class
            ├── settings.py           # Settings registry
            ├── api/                  # API endpoints
            │   ├── __init__.py
            │   ├── [endpoints].py
            │   └── admin_[endpoints].py
            ├── crud/                 # Database operations
            │   ├── __init__.py
            │   └── crud_[model].py
            ├── models/               # Data models
            │   ├── __init__.py
            │   └── [model].py
            ├── schemas/              # Pydantic schemas
            │   ├── __init__.py
            │   └── [schema].py
            ├── services/             # Business logic
            │   ├── __init__.py
            │   └── [service].py
            ├── middleware/           # Custom middleware
            │   ├── __init__.py
            │   └── [middleware].py
            ├── migrations/           # Database migrations
            │   ├── __init__.py
            │   └── v20250501/
            └── tests/                # Unit tests
                ├── __init__.py
                └── test_[feature].py
```

### 1. Module Registration (`__init__.py`)
```python
from .__version__ import __version__
from .module import MyModule
from .config import MySettings
from .settings import settings_registry

__all__ = ["MyModule", "MySettings", "__version__"]
```

### 2. Version Management (`__version__.py`)
```python
__title__ = "stufio-modules-mymodule"
__description__ = "My custom Stufio module"
__version__ = "0.1.0"
__author__ = "Your Name"
__license__ = "MIT"
```

### 3. Module Class (`module.py`)
```python
from fastapi import FastAPI
from typing import List, Tuple
import logging

from stufio.core.module_registry import ModuleInterface
from stufio.core.stufioapi import StufioAPI
from .api import api_router
from .middleware import MyMiddleware
from .__version__ import __version__

logger = logging.getLogger(__name__)

class MyModule(ModuleInterface):
    """My custom module for handling specific functionality."""

    version = __version__

    def register_routes(self, app: StufioAPI) -> None:
        """Register this module's routes with the FastAPI app."""
        from .api import router as api_router
        app.include_router(api_router, prefix=self.routes_prefix)

    def get_middlewares(self) -> List[Tuple]:
        """Return middleware classes for this module."""
        return [(MyMiddleware, {}, {})]

    async def on_startup(self, app: StufioAPI) -> None:
        """Called when the application starts up."""
        logger.info(f"Starting {self.__class__.__name__} v{self.version}")
        # Initialize any services, connections, etc.

    async def on_shutdown(self, app: StufioAPI) -> None:
        """Called when the application shuts down."""
        logger.info(f"Shutting down {self.__class__.__name__}")
        # Cleanup resources
```

### 4. Settings Configuration (`config.py`)
```python
from stufio.core.config import get_settings
from stufio.core.settings import ModuleSettings

settings = get_settings()

class MySettings(ModuleSettings):
    # Module-specific settings
    MY_FEATURE_ENABLED: bool = True
    MY_MAX_ITEMS: int = 100
    MY_CACHE_TTL: int = 3600
    MY_API_KEY: str = ""

# Register settings with core
settings.register_module_settings("mymodule", MySettings)
```

### 5. API Routes (`api/__init__.py`)
```python
from fastapi import APIRouter
from stufio.api.admin import admin_router

from .items import router as items_router
from .admin_items import router as admin_items_router

api_router = APIRouter()

# Public routes
api_router.include_router(items_router, tags=["items"])

# Admin routes
admin_router.include_router(admin_items_router, tags=["items"])
```

### 6. CRUD Operations (`crud/crud_item.py`)
```python
from typing import List, Optional
from stufio.crud.mongo_base import CRUDMongo
from ..models.item import Item
from ..schemas.item import ItemCreate, ItemUpdate

class CRUDItem(CRUDMongo[Item, ItemCreate, ItemUpdate]):
    async def get_by_category(self, category: str) -> List[Item]:
        return await self.get_multi(filters={"category": category})

    async def get_active_items(self) -> List[Item]:
        return await self.get_multi(filters={"is_active": True})

item_crud = CRUDItem(Item)
```

### 7. Data Models (`models/item.py`)
```python
from datetime import datetime
from typing import Optional
from odmantic import Field

from stufio.db.mongo_base import MongoBase, datetime_now_sec

class Item(MongoBase):
    name: str = Field(index=True)
    description: Optional[str] = None
    category: str = Field(index=True)
    price: float = Field(ge=0)
    is_active: bool = Field(default=True, index=True)
    created_at: datetime = Field(default_factory=datetime_now_sec)
    updated_at: datetime = Field(default_factory=datetime_now_sec)

    model_config = {
        "collection": "items",
        "indexes": [
            [("name", 1), ("category", 1)],  # Compound index
        ]
    }
```

### 8. Pydantic Schemas (`schemas/item.py`)
```python
from typing import Optional
from pydantic import BaseModel, Field

class ItemBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    category: str = Field(..., min_length=1, max_length=50)
    price: float = Field(..., ge=0)

class ItemCreate(ItemBase):
    pass

class ItemUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    category: Optional[str] = Field(None, min_length=1, max_length=50)
    price: Optional[float] = Field(None, ge=0)
    is_active: Optional[bool] = None

class ItemResponse(ItemBase):
    id: str
    is_active: bool
    created_at: datetime
    updated_at: datetime
```

### 9. Services (`services/item_service.py`)
```python
from typing import List, Optional
from ..crud.crud_item import item_crud
from ..schemas.item import ItemCreate, ItemUpdate

class ItemService:
    @staticmethod
    async def create_item(item_data: ItemCreate) -> Item:
        return await item_crud.create(item_data)

    @staticmethod
    async def get_items_by_category(category: str) -> List[Item]:
        return await item_crud.get_by_category(category)

    @staticmethod
    async def update_item(item_id: str, update_data: ItemUpdate) -> Optional[Item]:
        item = await item_crud.get(item_id)
        if item:
            return await item_crud.update(item, update_data)
        return None

item_service = ItemService()
```

### 10. Package Configuration (`pyproject.toml`)
```toml
[build-system]
requires = ["setuptools>=45", "wheel", "setuptools-scm"]
build-backend = "setuptools.build_meta"

[project]
name = "stufio-modules-mymodule"
version = "0.1.0"
description = "My custom Stufio module"
authors = [{name = "Your Name", email = "your.email@example.com"}]
license = {text = "MIT"}
requires-python = ">=3.11"
dependencies = [
    "stufio>=0.1.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-asyncio>=0.21.0",
]

[tool.setuptools.packages.find]
where = ["."]
include = ["stufio*"]
```

### Module Development Best Practices

1. **Follow Naming Conventions**: Use `stufio-modules-[name]` for packages
2. **Implement ModuleInterface**: Always extend the base interface
3. **Use Dependency Injection**: Leverage FastAPI's dependency system
4. **Handle Errors Gracefully**: Implement proper error handling and logging
5. **Write Tests**: Include comprehensive test coverage
6. **Document APIs**: Use FastAPI's automatic documentation features
7. **Follow Async Patterns**: Use async/await throughout your module
8. **Register Settings**: Always register module settings with the core
9. **Use Appropriate Databases**: Follow the database usage patterns
10. **Implement Proper Migrations**: Include database schema changes

## Common Anti-Patterns to Avoid

- Don't store large binary data in MongoDB (use object storage)
- Don't use ClickHouse for real-time updates (it's append-only)
- Don't store critical data only in Redis (it's volatile)
- Don't ignore connection errors (implement fallbacks)
- Don't skip metrics tracking (it's essential for monitoring)
- Don't hardcode database names or table names
- Don't forget to handle ObjectId serialization for MongoDB responses
- Don't create modules without proper migrations
- Don't skip module registration in `__init__.py`
- Don't forget to implement proper dependency injection